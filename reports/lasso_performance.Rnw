%  SET UP LaTeX DEFAULTS  --------------------------------------
\documentclass{article}
\usepackage[sc]{mathpazo}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{3}
% \usepackage[options]{algorithm2e}
\usepackage{url}
\usepackage{setspace}
\usepackage{relsize}
\usepackage{float}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{booktabs}

\usepackage[authoryear]{natbib}
\usepackage[nottoc]{tocbibind}
\usepackage[unicode=true,pdfusetitle,bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black]{hyperref}
\hypersetup{
    pdfstartview={XYZ null null 1}}
%\usepackage{breakurl}
\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}
\usepackage[buttonsize=1em]{animate}
\makeatother
\renewcommand{\bibname}{References}

\begin{document}

\title{Sparse Undirected Graphs for Spatiotemporal Modeling: Summary of LASSO Performance}
\author{Robert A. Giaquinto}
\maketitle

\begin{abstract}
   Abstract goes here!
\end{abstract}

\tableofcontents

%  Base KnitR code ------------------------------------------------------------------
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)

opts_chunk$set(fig.align='center',
    fig.show='hold',
    fig.pos='H',
    message=FALSE,
    warning=FALSE,
    echo=FALSE,
    par=TRUE)
options(width=80, stringsAsFactors=FALSE)

library(ggplot2)
library(scales)
library(reshape2)
library(dplyr)
library(xtable)
library(stringr)
library(readr)
library(glmnet)
library(glmnetUtils)
library(lubridate)
library(RColorBrewer)
library(ggmap)
library(geoR)

source_dir <- '/Users/robert/documents/umn/air_pollution/src/main/'
source(paste0(source_dir, 'Utility_Functions.R'))
source(paste0(source_dir, 'Lasso.R'))
source(paste0(source_dir, 'Data_Prep.R'))
@

<<training_parameters>>=
testing_months=6
training_months=24
verbose=FALSE
num_lambdas <- 25
var_list <- list(tar_var=tar_var, date_vars=date_vars, agg_vars=agg_vars, lag_vars=lag_vars)
@

<<lasso>>=
lasso_results <- Lasso(DF, var_list,
    num_lambdas=num_lambdas,
    testing_months=testing_months,
    training_months=training_months, verbose=verbose)

@

\section{Introduction}
As a baseline model for comparison, the air pollution (as measured by particulate matter less than 2.5 micrometers, denoted PM25) is modeled using regularized linear regression via the LASSO. The LASSO offers a feature select method since non-informative coefficients are driven towards zero, allowing many interactions of features to be tested. In particular, interactions between temporal, and lagged (or lagged moving average) features are considered. The LASSO assumes PM25 follows a guassian distribution.

The LASSO is trained on \Sexpr{training_months} months of data, with predictions and errors records on the following \Sexpr{testing_months} months of data. Then the training and testing dates are shifted forward in time \Sexpr{testing_months} months and the model is re-trained and re-tested. Results are saved for all values of lambdas across all windows -- instead of a traditional cross-validation approach which may find the best lambda (via CV) on a single training window and then move on. The advantages of this approach are that errors can be aggregated across moving windows in order to find a value of lambda which is most suitable for any point in time.


\section{Error as a Function of Model Complexity}
The primary means of evaluation of the LASSO is the root mean squared error (RMSE) calculated over all prediction windows by each lambda value. The lambda value is the parameter which governs model complexity in the LASSO. As shown in (EQUATION FOR LASSO), model complexity is measured by the absolute value of the coefficients. The plot below shows how RMSE varys by lambda. Larger values of lambda equate to larger penalties for complexity. As lambda increases the model approaches the null model in which predictions are simply the average PM25 seen in the training set. At the other extreme, when lambda is zero, the model is equivalent to linear regression. The plot below shows that a $lambda=$\Sexpr{round(lasso_results$best_lambda, 3)} results in the best predicted error on the test set of future data. Moreover, the model performs well, showing a drop in RMSE over the null model by \Sexpr{round(100*(1 - lasso_results$best_rmse/6.33)}\%
<<known_error>>=
p1 <- plot_error_curve(lasso_results)
print(p1)
@





\section{Distribution of Error Across Time and Space}
In addition to looking at the overall performance, it's helpful to examine how RMSE varies by time conditional on location, and location conditioned on time. In the case of time conditioned on location, this plot helps
<<win_loc_plots, out.width='.49\\textwidth'>>=
plot_error_distribution(lasso_results)
@
TODO re-add distribution in error across space


On a higher level, the RMSE for each particular is shown below:
<<lasso_window_error_table, results='asis'>>=
key_vars <- c("location_key", "datetime_key", "window", "actual")
keep_vars <- c(key_vars, paste0(c("predict", "error"),
    which(lasso_results$best_lambda == lambda_sequence(num_lambdas)))) # index of best lambda
best_errors <- as.data.frame(lasso_results$all_hourly_df[,keep_vars])
names(best_errors) <- c(key_vars, "predict", "error")

# what is the predicted error at each window (for optimal lambda)
window_error <- best_errors %>% group_by(window) %>%
    summarise(avg_actual = mean(actual), avg_predict = mean(predict), RMSE=rmse(error))
window_error <- window_error[order(window_error$RMSE, decreasing=FALSE),]
print(xtable(window_error, digits=4), include.rownames=FALSE)
rm(window_error)
@

And similarly for locations:
<<lasso_location_error_table, results='asis'>>=
# what is the predicted error at each window (for optimal lambda)
window_error <- best_errors %>% group_by(window) %>%
    summarise(avg_actual = mean(actual), avg_predict = mean(predict), RMSE=rmse(error))
window_error <- window_error[order(window_error$RMSE, decreasing=FALSE),]
print(xtable(window_error, digits=4), include.rownames=FALSE)
rm(window_error)
@



\section{Spatial Correlation}
Are the errors correlated?
<<error_correlation, out.width='.49\\textwidth'>>=
p1 <- plot_spatial_correlation(lasso_results)
map_df <- unique(DF[,c("Latitude", "Longitude", "location_key")])
map_df$location_key <- factor(map_df$location_key)
names(map_df) <- c("lat", "lon", "location")
map <- get_map(location = c(lon=mean(map_df$lon), lat=mean(map_df$lat)),
    zoom=9, maptype="toner-lite", color="bw", messaging=FALSE)
p2 <- ggmap(map) +
    geom_point(data=map_df,
        aes(x=lon, y=lat, colour=location), size=4) +
    labs(x="Longitude", y="Latitude")

print(p1)
print(p2)

@



\section{Spatial Interpolation}
Use krigging to interpolate locations
<<lasso_krig>>=
lat_long_df <- DF %>% group_by(location_key) %>% summarise(lat=mean(Latitude), lon=mean(Longitude))
aday <- best_errors[best_errors$set == "future" &
        best_errors$datetime_key >= 2013010200 &
        best_errors$datetime_key < 2013010300,]
krig_df <- left_join(x=aday, y=lat_long_df, by=c("location"="location_key"))
krig_df <- krig_df[,c("lat","lon","predict")]

# a <- read.table("http://www.stat.ucla.edu/~nchristo/statistics_c173_c273/kriging_11.txt", header=TRUE)
b <- as.geodata(krig_df)
b <- jitterDupCoords(x=b, max=.05)
prediction <- ksline(b, cov.model="exp",
    cov.pars=c(10,3.33), nugget=0,
    locations=c(29.90104,-95.32613))

n <- 25
x <- seq(min(krig_df$lat), max(krig_df$lat), length.out=n)
y <- seq(min(krig_df$lon), max(krig_df$lon), length.out=n)
xv <- rep(x, n)
yv <- rep(y, each=n)
in_mat <- as.matrix(cbind(xv,yv))
q <- ksline(b, cov.model="gaussian",cov.pars=c(2,.1), locations=in_mat)
cbind(q$predict[1:5], q$krige.var[1:5])
image(q, val=q$predict)
points(krig_df)


@





\end{document}